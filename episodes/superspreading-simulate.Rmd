---
title: 'Simulate transmission chains'
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- How to simulate transmission chains?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Create a short term projection using branching process with `{epichains}`.

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: prereq

## Prerequisites

Learners should familiarise themselves with following concept dependencies before working through this tutorial: 

**Statistics**: probability distributions. 

**Epidemic theory**: Reproduction number.

:::::::::::::::::::::::::::::::::

## Introduction

<!-- what we know -->

<!-- what we dont know -->

<!-- what we are going to do -->

We are going to use `{purrr}`

```{r,message=FALSE,warning=FALSE}
library(epichains)
library(epiparameter)
library(tidyverse)
```

## Superspreading in decision making

Transmission heterogeneity affects epidemic establishment and the ease of control ([Cori et al., 2017](https://royalsocietypublishing.org/doi/10.1098/rstb.2016.0371)). 

+ Greater heterogeneity reduces the chance of an outbreak emerging from single case. Individuals with more extreme amount of secondary cases are rare.

+ However, if the outbreak gets established, this heterogeneity can make an outbreak hard to control using *mass interventions* (which assumes transmission homogeneity), as a single uncontrolled case can generate a large number of secondary cases.

+ Conversely, heterogeneity in transmission may provide opportunities for *targeted interventions* if the individuals who contribute more to transmission (due to biological, environmental or behavioral factors) share socio-demographic or geographical characteristics that can be defined.

We can have an early understanding of a disease epidemic potential from the mean reproduction number $R$ and dispersion $k$ of an offspring distribution to answer questions like:

- What is the probability of an pathogen to cause large outbreak?
- What is the probability of an outbreak to get extinct?
- What is the probability to contain the ongoing outbreak?

::::::::::::::::::::::::::: testimonial

### Epidemic Risk assessment accounting for superspreading

These estimates vary non-linearly with respect to the mean reproduction number $R$ and dispersion $k$ of a given disease.

We invite you to read the `{superspreading}` vignette on [Epidemic risk](https://epiverse-trace.github.io/superspreading/articles/epidemic_risk.html)!

:::::::::::::::::::::::::::

## Simulation of uncontrolled outbreaks

simulation of uncontrolled outbreaks

- branching process
    + To assess the effect of individual variation on disease outbreaks, we analyse a branching process model with negative binomial offspring distribution

- estimate tree parameters using branching process
    + estimate size
    + estimate length

with estimated parameter we then can reconstruct tranmission chains to forecast and simulate interventions

![**An example of a transmission chain starting with a single case C1.** Cases are represented by blue circles and arrows indicate who infected whom. The chain grows through generations Gen 1, Gen 2, and Gen 3, producing cases C2, C3, C4, C5, and C6. The chain ends at generation Gen 3 with cases C4, C5, and C6. The size of C1’s chain is 6, including C1 (that is, the sum of all blue circles) and the length is 3, which includes Gen 1 (maximum number of generations reached by C1’s chain).](https://raw.githubusercontent.com/epiverse-trace/epichains/main/vignettes/img/transmission_chain_example.png)

### branching process

- probability generating function (pgf) of the offspring distribution 

## Get the offspring distribution

The MERS offspring distribution will follow a negative binomial distribution with mean (reproduction number $R$) and dispersion $k$ values estimated from the linelist and contact data of `mers_korea_2015` in the `{outbreaks}` R package in the previous episode.

```{r}
mers_offspring <- c(mean = 0.60, dispersion = 0.02)
```

:::::::::::::::::::::::::::: callout

The way we input an offspring distribution to `{epichains}` is by defining the R function that generates random values. For example, for a negative binomial distribution we use `rnbinom` with its corresponding `mu` and `size` arguments:

```r
  offspring_dist = rnbinom,
  mu = mers_offspring["mean"],
  size = mers_offspring["dispersion"],
```

The reference manual in `?rnbinom` tell us the specific arguments we require.

::::::::::::::::::::::::::::

:::::::::::::::::::::::::: spoiler

### Poisson and other distributions

`{epichains}` can accept any R function that generates random numbers, so the specified arguments will change depending of the R function used. The way to know this is by accessing the function reference manual.

For example, let's say that for the offspring distribution we want to use a Poisson distribution. First, read the argument required in the `?rpois` reference manual. Second, specify the `lambda` argument parameter, which is also known as rate or mean in the literature. In `{epichains}`, this can look like this:

```r
  offspring_dist = rpois,
  lambda = mers_offspring["mean"],
```

In this example we can specify `lambda = mers_offspring["mean"]` because in a negative binomial model, when the dispersion parameter $k$ approaches infinity ($k \rightarrow \infty$) the variance equals the mean. This makes the conventional Poisson model an special case of the negative binomial model. The mean of the negative binomial model (`mu`) can also be the mean of the poisson model (`lambda`). 

::::::::::::::::::::::::::

## Get generation time

The generation time distribution is often approximated by the [serial interval](../learners/reference.md#serialinterval) distribution.  This approximation is frequent because it is easier to observe and measure the onset of symptoms than the onset of infectiousness.

:::::::::::::::::::::::::::::::: spoiler

### generation time vs serial interval

![A schematic of the relationship of different time periods of transmission between an infector and an infectee in a transmission pair. Exposure window is defined as the time interval having viral exposure, and transmission window is defined as the time interval for onward transmission with respect to the infection time ([Chung Lau et al., 2021](https://academic.oup.com/jid/article/224/10/1664/6356465)).](fig/serial-interval-observed.jpeg)

However, using the *serial interval* as an approximation of the *generation time* is primarily valid for diseases in which infectiousness starts after symptom onset ([Chung Lau et al., 2021](https://academic.oup.com/jid/article/224/10/1664/6356465)). In cases where infectiousness starts before symptom onset, the serial intervals can have negative values, which is the case for diseases with pre-symptomatic transmission ([Nishiura et al., 2020](https://www.ijidonline.com/article/S1201-9712(20)30119-3/fulltext#gr2)).

::::::::::::::::::::::::::::::::

Let's use the `{epiparameter}` package to access and use the available serial interval for MERS disease:

```{r,message=FALSE,warning=FALSE}
serial_inverval <- epidist_db(
  disease = "mers",
  epi_dist = "serial",
  single_epidist = TRUE
)

plot(serial_inverval, day_range = 0:25)
```

```{r,echo=FALSE}
serial_summary <- serial_inverval$summary_stats %>%
  as_tibble() %>%
  select(mean, sd) %>%
  distinct(.keep_all = TRUE)
```

The serial interval for MERS has a mean of `r serial_summary$mean` days and standard deviation `r serial_summary$sd` days.

:::::::::::::::::::::::::::: callout

In `{epichains}` we need to specify the generation time as a function that generates random numbers. Using `{epiparameter}` has the advantage of using the distribution function `epiparameter::generate()` for this input. This will look like this:

```r
function(x) generate(x = serial_inverval, times = x)
```

This interface is similar to the one used by `{cfr}` to link with `{epiparameter}`. For further context, read the [work with delay distributions](https://epiverse-trace.github.io/cfr/articles/delay_distributions.html) vignette.

::::::::::::::::::::::::::::

## Simulate a single chain

Now we are prepared to use the `simulate_chains()` function from `{epichains}` to create **one** transmission chain:

```{r,message=FALSE,warning=FALSE,eval=FALSE}
simulate_chains(
  # simulation controls
  index_cases = 5,
  statistic = "size",
  # offspring
  offspring_dist = rnbinom,
  mu = mers_offspring["mean"],
  size = mers_offspring["dispersion"],
  # generation
  generation_time = function(x) generate(x = serial_inverval, times = x)
)
```

`simulate_chains()` requires, at least, three sets of arguments:

- simulation controls,
- offspring distribution, and
- generation time.

Lines above we described how to specify the offspring distribution and generation time. The **simulation controls** include, at least, two arguments:

- `index_case`, which define the number of index cases to simulate transmission chains for, and
- `statistic`, which define a chain statistic to track (either `"size"` or `"length"`) as the stopping criteria for each chain being simulated.

::::::::::::::::::::::::::: callout

### Stopping criteria

This is an exclusive feature of `{epichains}`. Branching process simulations end when they have gone extinct, that is, no more offspring are being produced, or because of some stopping criterion.

:::::::::::::::::::::::::::

The output of the `simulate_chains()` function creates a `<epichains>` class object.

## Simulate multiple chains

We can use `simulate_chains()` to create multiple chains and increase the probability to simulate uncontrolled outbreaks projections given an overdispersed offspring distribution.

We need to specify three additional elements:

- `set.seed(<integer>)`, which is a random number generator function with a specified seed value, the `<integer>` number, to ensure consistent results across different runs of the code.
- `number_chains`, which defines the number of simulation to run.
- `initial_cases`, which defines the number of initial cases to input to the `index_cases` argument explained lines above.

```{r}
# Set seed for random number generator
set.seed(33)
# Number of simulation runs
number_chains <- 1000
# Number of initial cases
initial_cases <- 1
```

`number_chains` and `initial_cases` are conveniently stored in objects to facilitate its reuse downstream in the workflow.

:::::::::::::::::::::::::::::: checklist

### Iteration using purrr

[Iteration](https://r4ds.hadley.nz/iteration.html) aims to repeatedly perform the same action on different objects.

Learn how to use the core `{purrr}` functions like `map()` from the YouTube tutorial on [How to purrr](https://www.youtube.com/watch?v=nd-Y8b22YaQ) by Equitable Equations.

Or if you previously used the `*apply` family of functions, visit the package vignette on [purrr base R](https://purrr.tidyverse.org/articles/base.html) shares key differences, direct translations, and examples.

::::::::::::::::::::::::::::::

To get multiple chains, we need to apply the `simulate_chains()` function to each chain defined by a sequence of numbers from 1 to `number_chains`.

First, let's make a draft sketch of how we use `purrr::map()` with `epichains::simulate_chains()`. The `map()` function requires two arguments:

- `.x`, with a vector of numbers, and
- `.f`, a function to iterate to each value of the vector.

The `sim` element is placed to register the iteration number (**chain ID**) as a new column in the `<epichains>` output. The `purrr::list_rbind()` function aims to combine all the list outputs from `map()`:

```r
map(
  # vector of numbers (chain IDs)
  .x = seq_len(number_chains),
  # function to iterate to each chain ID number
  .f = function(sim) {
    simulate_chains(...) %>%
      # creates a column with the chain ID number
      mutate(chain_id = sim)
  }
) %>%
  # combine list outputs (for each chain ID) into a single data frame
  list_rbind()
```

Now, we are prepared to use `map()` to iterate `simulate_chains()` in a vector from 1 to `r number_chains`:

```{r}
simulated_chains_map <-
  # iterate one function across multiple numbers (chain IDs)
  map(
    # vector of numbers (chain IDs)
    .x = seq_len(number_chains),
    # function to iterate to each chain ID number
    .f = function(sim) {
      simulate_chains(
        # simulation controls
        index_cases = initial_cases,
        statistic = "size",
        # offspring
        offspring_dist = rnbinom,
        mu = mers_offspring["mean"],
        size = mers_offspring["dispersion"],
        # generation
        generation_time = function(x) generate(x = serial_inverval, times = x)
      ) %>%
        # creates a column with the chain ID number
        mutate(chain_id = sim)
    }
  ) %>%
  # combine list outputs (for each chain ID) into a single data frame
  list_rbind()
```

```{r,echo=FALSE,eval=FALSE}
# view infectee number per simulation
simulated_chains_map %>%
  as_tibble() %>%
  count(chain_id, sort = TRUE)
```

::::::::::::::::::::::::::::::::: callout

### Read the epichains output

```{r,echo=FALSE}
#### get simulated chain with more infections --------------------------------

chains_subgroup <- simulated_chains_map %>%
  as_tibble() %>%
  group_by(chain_id) %>%
  distinct(infector_id) %>%
  count(chain_id) %>%
  filter(n < 5, n >= 3) %>%
  pull(chain_id)

chain_to_observe <- simulated_chains_map %>%
  as_tibble() %>%
  count(chain_id, sort = TRUE) %>%
  filter(
    magrittr::is_in(
      chain_id, chains_subgroup
    )
  ) %>%
  filter(n < 10) %>%
  filter(n == max(n)) %>%
  slice_min(chain_id) %>%
  pull(chain_id)
```

To explore the output format of the `<epichains>` class object of name `simulated_chains_map`, let's observe closely the simulated `chain_id` number `r chain_to_observe`. Let's use `dplyr::filter()` for this:

```{r}
#### get epichain summary ----------------------------------------------------

simulated_chains_map %>%
  filter(chain_id == chain_to_observe)
```

Key elements exclusive from this output are in the **footer**:

```output
Number of infectors (known): 3
Number of generations: 3
```

The simulated `chain_id` number `r chain_to_observe` has three known infector and three generations. These numbers are more visible when reading the `<epichains>` objects as a data frame:

```{r}
#### infector-infectee data frame --------------------------------------------

simulated_chains_map %>%
  filter(chain_id == chain_to_observe) %>%
  as_tibble()
```

The **story** that chain `r chain_to_observe` is telling is: "One index case infected `sim_id = 1`. Then, in the second generation of transmissions, `sim_id = 1` infected five cases. Later, in the third generation of transmissions, `sim_id = 2` infected three new cases."

The output data frame collects **infectees** as the observation unit: 
- Each infectee has a `sim_id`. 
- Each _infectee_ that behaved as an _infector_ is registered in the `infector_id` column using `sim_id` of that infectee. 
- Each infectee got infected in a specific `generation` and (continuous) `time`. 
- The simulation number is registered under the `chain_id` column.

**Note:** The `Number of infectors (known)` includes the `NA` observation under the `infector_id` column. This refers to the infector specified as index case (in the `index_cases` argument), which started the transmission chain to the infectee of `sim_id = 1`, at `generation = 1`, and `time = 0`.

:::::::::::::::::::::::::::::

## Visualize multiple chains

To visualize the simulated chains, we need some pre-processing. First, let's use `{dplyr}` to get round time numbers, to resemble surveillance days. Second, count the daily number of cases in each simulation (by `chain_id`). Third, calculate the cumulative number of cases within simulation.

```{r}
# daily aggregate of cases
simulated_chains_day <- simulated_chains_map %>%
  # use data.frame output from <epichains> object
  as_tibble() %>%
  # transform chain ID column to factor (categorical variable)
  mutate(chain_id = as_factor(chain_id)) %>%
  # get the round number (day) of infection times
  mutate(day = ceiling(time)) %>%
  # count the daily number of cases each simulation (chain ID)
  count(chain_id, day, name = "cases") %>%
  # calculate the cumulative number of cases for each simulation (chain ID)
  group_by(chain_id) %>%
  mutate(cases_cumsum = cumsum(cases)) %>%
  ungroup()
```

Previous to the plot, let's create a summary table with the total time duration and size of each chain. We can use the `{dplyr}` "combo" of `group_by()`, `summarise()` and `ungroup()`:

```{r}
# Summarise the chain duration and size
sim_chains_max <-
  simulated_chains_day %>%
  group_by(chain_id) %>%
  summarise(
    # duration
    day_max = max(day),
    # size
    cases_total = max(cases_cumsum)
  ) %>%
  ungroup()
```

Now, we are prepared for using the `{ggplot2}` package:

```{r}
# Visualize transmission chains by cumulative cases
ggplot() +
  # create grouped chain trajectories
  geom_line(
    data = simulated_chains_day,
    mapping = aes(
      x = day,
      y = cases_cumsum,
      group = chain_id
    ),
    color = "gray",
    show.legend = FALSE
  ) +
  # create points to visualize the chain end point
  geom_point(
    data = sim_chains_max,
    mapping = aes(
      x = day_max,
      y = cases_total,
      group = chain_id,
      color = chain_id
    ),
    show.legend = FALSE
  ) +
  # define a 100-case threshold
  geom_hline(aes(yintercept = 100), lty = 2) +
  labs(
    x = "Day",
    y = "Cumulative cases"
  )
```


```{r,echo=FALSE,message=FALSE,warning=FALSE}
# proportion that reached the 100-case threshold
threshhold_summary <- sim_chains_max %>%
  arrange(desc(day_max)) %>%
  filter(cases_total > 100) %>%
  count(name = "chains_theshold") %>%
  mutate(chains_number = number_chains) %>%
  mutate(chains_percentage = chains_theshold / chains_number * 100)

chains_extinct <- sim_chains_max %>%
  arrange(desc(day_max)) %>%
  filter(day_max > 0) %>%
  summarise(
    extinct_duration_median = median(day_max),
    extinct_size_median = median(cases_total)
  )

chains_null <- sim_chains_max %>%
  arrange(desc(cases_total)) %>%
  filter(day_max < 1) %>%
  nrow()
```

Although most introductions of `r initial_cases` index case do not generate secondary cases (N = `r chains_null`) or most outbreaks rapidly become extinct (median duration of `r chains_extinct$extinct_duration_median` and median size of `r chains_extinct$extinct_size_median`), only `r threshhold_summary$chains_theshold` epidemic trajectories among `r threshhold_summary$chains_number` simulations (`r threshhold_summary$chains_percentage`%) can reach to more than 100 infected cases. This finding is particularly remarkable because the reproduction number $R$ is less than 1 (offspring distribution mean of `r mers_offspring[["mean"]]`), but, given an offspring distribution dispersion parameter of `r mers_offspring[["dispersion"]]`, it shows the potential for explosive outbreaks of MERS disease.

::::::::::::::::::::::::::::::::::: spoiler

### Observed cases vs simulated chains

Let's overlap the cumulative number of observed cases using the linelist object from the `mers_korea_2015` dataset of the `{outbreaks}` R package. To prepare the dataset we use `{incidence2}` to convert the linelist to an `<incidence2>` object, complete the missing dates of the time series with `complete_dates()`

```{r,warning=FALSE,message=FALSE}
library(outbreaks)

mers_cumcases <- mers_korea_2015$linelist %>%
  # incidence2 workflow
  incidence2::incidence(date_index = "dt_onset") %>%
  incidence2::complete_dates() %>%
  # wrangling using {dplyr}
  mutate(count_cumsum = cumsum(count)) %>%
  rownames_to_column(var = "day") %>%
  mutate(day = as.numeric(day))
```

Use `plot()` to make an incidence plot:

```{r}
# plot the incidence2 object
plot(mers_cumcases)
```

:::::::::::::::::::::::::::::::::::

When plotting the observed number of cumulative cases from the Middle East respiratory syndrome (MERS) outbreak in South Korea in 2015, alongside the previously simulated chains, we identify that the observed cases followed a trajectory that resembled a simulated explosive outbreak.

```{r,echo=FALSE}
# Observed cases vs Simulated transmission chains
mers_cumcases_type <-
  mers_cumcases %>%
  mutate(type = "Observed")
simulated_chains_day_type <-
  simulated_chains_day %>%
  mutate(type = "Simulated")

ggplot() +
  geom_line(
    data = simulated_chains_day_type,
    mapping = aes(
      x = day,
      y = cases_cumsum,
      group = chain_id,
      color = type
    )
  ) +
  geom_hline(aes(yintercept = 100), lty = 2) +
  geom_line(
    data = mers_cumcases_type,
    mapping = aes(
      x = day,
      y = count_cumsum,
      color = type
    ),
    linewidth = 1.5
  ) +
  labs(
    x = "Day since first report",
    y = "Cumulative cases",
    color = "Type"
  )
```

Notice that the proportion of simulated outbreaks that reached the 100-case threshold increases with the increase of the dispersion parameter $k$.

![**Growth of simulated outbreaks with R0 = 1.5 and one initial case, conditional on non-extinction.** Boxes show median and interquartile range (IQR) of the first disease generation with 100 cases; whiskers show most extreme values within 1.5 × IQR of the boxes, and crosses show outliers. Percentages show the proportion of 10,000 simulated outbreaks that reached the 100-case threshold ([Lloyd-Smith et al., 2005](https://www.nature.com/articles/nature04153)).](fig/see-nature04153_Fig2-c.jpg)

:::::::::::::::::::::: testimonial

### Early spread projections

In the initial phase of the epidemic you can use `{epichains}` to apply a branching process model to project the number of future cases. Validation analysis showed that this is a rapid and low detail model with forecast prediction intervals that are too certain ([Pearson et al., 2020](https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2020.25.18.2000543#validationofthemodel-1)).

We invite you to read the vignette on [Projecting infectious disease incidence: a COVID-19 example](https://epiverse-trace.github.io/epichains/articles/projecting_incidence.html)!

::::::::::::::::::::::

## Challenges

:::::::::::::::::::::::::: challenge

Evaluate the potential of Ebola to generate explosive outbreaks. Use the appropriate package to access delay data from previous outbreaks.

:::::::::::::: hint

With `{epiparameter}` you can access and use delay distributions from previous outbreaks.

::::::::::::::

:::::::::::::: solution

```{r,message=FALSE,warning=FALSE}
ebola_offspring <- epidist_db(
  disease = "ebola",
  epi_dist = "offspring",
  single_epidist = TRUE
)

ebola_serial <- epidist_db(
  disease = "ebola",
  epi_dist = "serial interval",
  single_epidist = TRUE
)
```

<!-- [pending to complete] -->

::::::::::::::

:::::::::::::::::::::::::

:::::::::::::::::::::::::: challenge

[Christian Althaus](https://www.thelancet.com/journals/laninf/article/PIIS1473-3099(15)70135-0/fulltext) reused data published by [Faye et al., 2015 (Figure 2)](https://www.thelancet.com/journals/laninf/article/PIIS1473-3099(14)71075-8/fulltext#gr2) on the transmission tree on Ebola virus disease in Conakry, Guinea, 2014.

```{r,message=FALSE,warning=FALSE}
# Number of individuals in the trees
n <- 152
# Number of secondary cases for all individuals
c1 <- c(1, 2, 2, 5, 14, 1, 4, 4, 1, 3, 3, 8, 2, 1, 1,
        4, 9, 9, 1, 1, 17, 2, 1, 1, 1, 4, 3, 3, 4, 2,
        5, 1, 2, 2, 1, 9, 1, 3, 1, 2, 1, 1, 2)
c0 <- c(c1, rep(0, n - length(c1)))

c0 %>%
  enframe() %>%
  ggplot(aes(value)) +
  geom_histogram()
```

Estimate the offspring distribution from the distribution of secondary cases. Then estimate the large outbreak potential from this data.

::::::::::: hint

...

:::::::::::

::::::::::: solution

<!-- [pending to complete] -->

Remarkable, even with R0 less than 1
with potentially explosive outbreaks. the observed variation in individual infectiousness in Ebola
means that although the probability of extinction is high, new index cases also have the potential for explosive regrowth of the epidemic.

:::::::::::

:::::::::::::::::::::::::::::

:::::::::::::::::::: challenge

Calculate probabilities for Ebola of a large outbreak and to contain an epidemic. Use the appropriate package to access delay data from previous outbreaks.

:::::::::::::::::: hint

With `{epiparameter}` you can access and use delay distributions from previous outbreaks.

With `{superspreading}` you can get numerical solutions to processes that `{epichains}` solve using branching processes. We invite you to read the `{superspreading}` vignette on [Epidemic risk](https://epiverse-trace.github.io/superspreading/articles/epidemic_risk.html)!

::::::::::::::::::

::::::::::::::::::::: hint

Here is an example with the MERS offspring distribution estimates:

```{r,message=FALSE,warning=FALSE}
library(superspreading)
```

```{r}
# estimate probability to contain
probability_contain(
  R = mers_offspring["mean"],
  k = mers_offspring["dispersion"],
  num_init_infect = 1,
  case_threshold = 100
)

# Estimate probability of large outbreak
# with 5 independent imported cases
probability_epidemic(
  R = mers_offspring["mean"],
  k = mers_offspring["dispersion"],
  num_init_infect = 5
)
```

::::::::::::::::::

:::::::::::::::::: solution

```{r}
#' get ebola params
```

<!-- [pending to complete] -->

::::::::::::::::::

:::::::::::::::::::::::::::::::::::::


::::::::::::::::::::::::::::::::::::: keypoints 

- Use `{epichains}` to simulate the large outbreak potential of diseases with overdispersed offspring distributions.

::::::::::::::::::::::::::::::::::::::::::::::::

