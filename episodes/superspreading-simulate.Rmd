---
title: 'Simulate transmission chains'
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- How to simulate transmission chains?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Create a short term projection using branching process with `{epichains}`.

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: prereq

## Prerequisites

Learners should familiarise themselves with following concept dependencies before working through this tutorial: 

**Statistics**: probability distributions. 

**Epidemic theory**: Reproduction number.

:::::::::::::::::::::::::::::::::

## Introduction

<!-- what we know -->

<!-- what we dont know -->

<!-- what we are going to do -->

We are going to use `{purrr}`

```{r,message=FALSE,warning=FALSE}
library(epichains)
library(epiparameter)
library(tidyverse)
```

## Superspreading in decision making

Transmission heterogeneity affects epidemic establishment and the ease of control ([Cori et al., 2017](https://royalsocietypublishing.org/doi/10.1098/rstb.2016.0371)). 

+ Greater heterogeneity reduces the chance of an outbreak emerging from single case. Individuals with more extreme amount of secondary cases are rare.

+ However, if the outbreak gets established, this heterogeneity can make an outbreak hard to control using *mass interventions* (which assumes transmission homogeneity), as a single uncontrolled case can generate a large number of secondary cases.

+ Conversely, heterogeneity in transmission may provide opportunities for *targeted interventions* if the individuals who contribute more to transmission (due to biological, environmental or behavioral factors) share socio-demographic or geographical characteristics that can be defined.

We can have an early understanding of a disease epidemic potential from the mean reproduction number $R$ and dispersion $k$ of an offspring distribution to answer questions like:

- What is the probability of an pathogen to cause large outbreak?
- What is the probability of an outbreak to get extinct?
- What is the probability to contain the ongoing outbreak?

::::::::::::::::::::::::::: testimonial

### Epidemic Risk assessment accounting for superspreading

These estimates vary non-linearly with respect to the mean reproduction number $R$ and dispersion $k$ of a given disease.

We invite you to read the `{superspreading}` vignette on [Epidemic risk](https://epiverse-trace.github.io/superspreading/articles/epidemic_risk.html)!

:::::::::::::::::::::::::::

## Simulation of uncontrolled outbreaks

simulation of uncontrolled outbreaks

- branching process
    + To assess the effect of individual variation on disease outbreaks, we analyse a branching process model with negative binomial offspring distribution

- estimate tree parameters using branching process
    + estimate size
    + estimate length

with estimated parameter we then can reconstruct tranmission chains to forecast and simulate interventions

![**An example of a transmission chain starting with a single case C1.** Cases are represented by blue circles and arrows indicate who infected whom. The chain grows through generations Gen 1, Gen 2, and Gen 3, producing cases C2, C3, C4, C5, and C6. The chain ends at generation Gen 3 with cases C4, C5, and C6. The size of C1’s chain is 6, including C1 (that is, the sum of all blue circles) and the length is 3, which includes Gen 1 (maximum number of generations reached by C1’s chain).](https://raw.githubusercontent.com/epiverse-trace/epichains/main/vignettes/img/transmission_chain_example.png)

### branching process

- probability generating function (pgf) of the offspring distribution 

## Get the offspring distribution

The MERS offspring distribution will follow a negative binomial distribution with mean (reproduction number $R$) and dispersion $k$ values estimated from the linelist and contact data of `mers_korea_2015` in the `{outbreaks}` R package in the previous episode.

```{r}
mers_offspring <- c(mean = 0.60, dispersion = 0.02)
```

The way we input an offspring distribution to `{epichains}` is by defining the R function that generates random values. For example, for a negative binomial distribution we use `rnbinom` with its corresponding `mu` and `size` arguments:

```r
  offspring_dist = rnbinom,
  mu = mers_offspring["mean"],
  size = mers_offspring["dispersion"],
```

The reference manual in `?rnbinom` tell us the specific arguments we require.

:::::::::::::::::::::::::: spoiler

### Poisson and other distributions

`{epichains}` can accept any R function that generates random numbers, so the specified arguments will change depending of the R function used. The way to know this is by accessing the function reference manual.

For example, let's say that for the offspring distribution we want to use a Poisson distribution. First, read the argument required in the `?rpois` reference manual. Second, specify the `lambda` argument parameter, which is also known as rate or mean in the literature. In `{epichains}`, this can look like this:

```r
  offspring_dist = rpois,
  lambda = mers_offspring["mean"],
```

In this example we can specify `lambda = mers_offspring["mean"]` because in a negative binomial model, when the dispersion parameter $k$ approaches infinity ($k \rightarrow \infty$) the variance equals the mean. This makes the conventional Poisson model an special case of the negative binomial model.

::::::::::::::::::::::::::

## Get generation time

The generation time distribution is often approximated by the [serial interval](../learners/reference.md#serialinterval) distribution.  This approximation is frequent because it is easier to observe and measure the onset of symptoms than the onset of infectiousness.

:::::::::::::::::::::::::::::::: spoiler

### generation time vs serial interval

![A schematic of the relationship of different time periods of transmission between an infector and an infectee in a transmission pair. Exposure window is defined as the time interval having viral exposure, and transmission window is defined as the time interval for onward transmission with respect to the infection time ([Chung Lau et al., 2021](https://academic.oup.com/jid/article/224/10/1664/6356465)).](fig/serial-interval-observed.jpeg)

However, using the *serial interval* as an approximation of the *generation time* is primarily valid for diseases in which infectiousness starts after symptom onset ([Chung Lau et al., 2021](https://academic.oup.com/jid/article/224/10/1664/6356465)). In cases where infectiousness starts before symptom onset, the serial intervals can have negative values, which is the case for diseases with pre-symptomatic transmission ([Nishiura et al., 2020](https://www.ijidonline.com/article/S1201-9712(20)30119-3/fulltext#gr2)).

::::::::::::::::::::::::::::::::

Let's use the `{epiparameter}` package to access and use the available serial interval for MERS disease:

```{r,message=FALSE,warning=FALSE}
serial_inverval <- epidist_db(
  disease = "mers",
  epi_dist = "serial",
  single_epidist = TRUE
)

plot(serial_inverval, day_range = 0:25)
```

```{r,echo=FALSE}
serial_summary <- serial_inverval$summary_stats %>%
  as_tibble() %>%
  select(mean, sd) %>%
  distinct(.keep_all = TRUE)
```

The serial interval for MERS has a mean of `r serial_summary$mean` days and standard deviation `r serial_summary$sd` days.

In `{epichains}` we need to specify the generation time as a function that generates random numbers. Using `{epiparameter}` has the advantage of using the distribution function `epiparameter::generate()` for this input. This will look like this:

```r
function(x) generate(x = serial_inverval, times = x)
```

This interface is similar to the one used by `{cfr}` to link with `{epiparameter}`. For further context, read the [work with delay distributions](https://epiverse-trace.github.io/cfr/articles/delay_distributions.html) vignette.

## Simulate a single chain

Now we are prepared to use the `simulate_chains()` function from `{epichains}` to create one transmission chain:

```{r,message=FALSE,warning=FALSE,eval=FALSE}
simulate_chains(
  # simulation controls
  index_cases = 5,
  statistic = "size",
  # offspring
  offspring_dist = rnbinom,
  mu = mers_offspring["mean"],
  size = mers_offspring["dispersion"],
  # generation
  generation_time = function(x) generate(x = serial_inverval, times = x)
)
```

`simulate_chains()` requires, at least, three sets of arguments:

- simulation controls,
- offspring distribution, and
- generation time.

Lines above we described how to specify the offspring distribution and generation time. The simulation controls

generates a `<epichains>` object

the output dataframe collects
infectees as observation unit
each infectee has a sim_id
the infector sim_id of each infectee is in infector_id
infectee got infected in generation and time
as part of the `chain_id` chain

## Simulate multiple chains

```{r}
# Set seed for random number generator
set.seed(33)
# Number of simulation runs
number_chains <- 1000
# Number of initial cases
initial_cases <- 1

```

:::::::::::::::::::::::::::::: checklist

### Iteration using purrr

[Iteration](https://r4ds.hadley.nz/iteration.html) aims to repeatedly perform the same action on different objects.

Learn how to use the core `{purrr}` functions like `map()` from the YouTube tutorial on [How to purrr](https://www.youtube.com/watch?v=nd-Y8b22YaQ) by Equitable Equations.

Or if you previously used the `*apply` family of functions, visit the package vignette on [purrr base R](https://purrr.tidyverse.org/articles/base.html) shares key differences, direct translations, and examples.

::::::::::::::::::::::::::::::

To get multiple chains, we need to apply the `simulate_chains()` function to each chain defined by a sequence of numbers from 1 to `number_chains`.

Let's use `map()`:

```{r}
simulated_chains_map <-
  # iterate one function across multiple numbers (chain IDs)
  map(
    # vector of numbers (chain IDs)
    .x = seq_len(number_chains),
    # function to iterate to each chain ID number
    .f = function(sim) {
      simulate_chains(
        # simulation controls
        index_cases = initial_cases,
        statistic = "size",
        # offspring
        offspring_dist = rnbinom,
        mu = mers_offspring["mean"],
        size = mers_offspring["dispersion"],
        # generation
        generation_time = function(x) generate(x = serial_inverval, times = x)
      ) %>%
        # creates a column with the chain ID number
        mutate(chain_id = sim)
    }
  ) %>%
  # combine list outputs (for each chain ID) into a single data frame
  list_rbind()
```

```{r,echo=FALSE,eval=FALSE}
# view infectee number per simulation
simulated_chains_map %>%
  as_tibble() %>%
  count(chain_id, sort = TRUE)
```

```{r,echo=FALSE}
#### get simulated chain with more infections --------------------------------

chains_subgroup <- simulated_chains_map %>%
  as_tibble() %>%
  group_by(chain_id) %>%
  distinct(infector_id) %>%
  count(chain_id) %>%
  filter(n < 5, n >= 3) %>%
  pull(chain_id)

chain_to_observe <- simulated_chains_map %>%
  as_tibble() %>%
  count(chain_id, sort = TRUE) %>%
  filter(
    magrittr::is_in(
      chain_id, chains_subgroup
    )
  ) %>%
  filter(n < 10) %>%
  filter(n == max(n)) %>%
  slice_min(chain_id) %>%
  pull(chain_id)
```

Let's observe closely the simulated `chain_id` number `r chain_to_observe` with three generations.

get epichain summary

```{r}
#### get epichain summary ----------------------------------------------------

simulated_chains_map %>%
  filter(chain_id == chain_to_observe)
```

the `NA` includes the infector of the index case, for that reason (known) cases

infectee-infector data frame

```{r}
#### infector-infectee data frame --------------------------------------------

simulated_chains_map %>%
  filter(chain_id == chain_to_observe) %>%
  as_tibble()
```


## Visualize multiple chains

```{r}
# daily aggregate of cases
simulated_chains_day <- simulated_chains_map %>%
  # use data.frame output from <epichains> object
  as_tibble() %>%
  # transform chain ID column to factor (categorical variable)
  mutate(chain_id = as_factor(chain_id)) %>%
  # get the round number (day) of infection times
  mutate(day = ceiling(time)) %>%
  # count the daily number of cases each simulation (chain ID)
  count(chain_id, day, name = "cases") %>%
  # calculate the cumulative number of cases for each simulation (chain ID)
  group_by(chain_id) %>%
  mutate(cases_cumsum = cumsum(cases)) %>%
  ungroup()
```

```{r}
# Summarise the chain duration and size
sim_chains_max <-
  simulated_chains_day %>%
  group_by(chain_id) %>%
  summarise(
    # duration
    day_max = max(day),
    # size
    cases_total = max(cases_cumsum)
  ) %>%
  ungroup()
```

```{r}
# Visualize transmission chains by cumulative cases
ggplot() +
  geom_line(
    data = simulated_chains_day,
    mapping = aes(
      x = day,
      y = cases_cumsum,
      group = chain_id,
      color = chain_id
    ),
    show.legend = FALSE
  ) +
  geom_point(
    data = sim_chains_max,
    mapping = aes(
      x = day_max,
      y = cases_total,
      group = chain_id,
      color = chain_id
    ),
    show.legend = FALSE
  ) +
  geom_hline(aes(yintercept = 100), lty = 2) +
  labs(
    x = "Day",
    y = "Cumulative cases"
  )
```


```{r,echo=FALSE,message=FALSE,warning=FALSE}
# proportion that reached the 100-case threshold
threshhold_summary <- sim_chains_max %>%
  arrange(desc(day_max)) %>%
  filter(cases_total > 100) %>%
  count(name = "chains_theshold") %>%
  mutate(chains_number = number_chains) %>%
  mutate(chains_percentage = chains_theshold / chains_number * 100)

chains_extinct <- sim_chains_max %>%
  arrange(desc(day_max)) %>%
  filter(day_max > 0) %>%
  summarise(
    extinct_duration_median = median(day_max),
    extinct_size_median = median(cases_total)
  )

chains_null <- sim_chains_max %>%
  arrange(desc(cases_total)) %>%
  filter(day_max < 1) %>%
  nrow()
```

Although most introductions do not generate secondary cases (N = `r chains_null`) or most outbreaks rapidly become extinct (median duration of `r chains_extinct$extinct_duration_median` and median size of `r chains_extinct$extinct_size_median`), only `r threshhold_summary$chains_theshold` epidemic trajectories among `r threshhold_summary$chains_number` simulations (`r threshhold_summary$chains_percentage`%) can reach to more than 100 infected cases. This finding is particularly remarkable because the reproduction number $R$ is less than 1 (offspring distribution mean of `r mers_offspring[["mean"]]`), but, given an offspring distribution dispersion parameter of `r mers_offspring[["dispersion"]]`, it shows the potential for explosive outbreaks of MERS disease.

::::::::::::::::::::::::::::::::::: spoiler

### Observed cases vs simulated chains

Let's overlap the cumulative number of observed cases using the linelist object from the `mers_korea_2015` dataset of the `{outbreaks}` R package. To prepare the dataset we use `{incidence2}` to convert the linelist to an `<incidence2>` object, complete the missing dates of the time series with `complete_dates()`

```{r,warning=FALSE,message=FALSE}
library(outbreaks)

mers_cumcases <- mers_korea_2015$linelist %>%
  # incidence2 workflow
  incidence2::incidence(date_index = "dt_onset") %>%
  incidence2::complete_dates() %>%
  # wrangling using {dplyr}
  mutate(count_cumsum = cumsum(count)) %>%
  rownames_to_column(var = "day") %>%
  mutate(day = as.numeric(day))
```

Use `plot()` to make an incidence plot:

```{r}
# plot the incidence2 object
plot(mers_cumcases)
```

:::::::::::::::::::::::::::::::::::

When plotting the observed number of cumulative cases from the Middle East respiratory syndrome (MERS) outbreak in South Korea in 2015, alongside the previously simulated chains, we identify that the observed cases followed a trajectory that resembled a simulated explosive outbreak.

```{r,echo=FALSE}
# Observed cases vs Simulated transmission chains
mers_cumcases_type <-
  mers_cumcases %>%
  mutate(type = "Observed")
simulated_chains_day_type <-
  simulated_chains_day %>%
  mutate(type = "Simulated")

ggplot() +
  geom_line(
    data = simulated_chains_day_type,
    mapping = aes(
      x = day,
      y = cases_cumsum,
      group = chain_id,
      color = type
    )
  ) +
  geom_hline(aes(yintercept = 100), lty = 2) +
  geom_line(
    data = mers_cumcases_type,
    mapping = aes(
      x = day,
      y = count_cumsum,
      color = type
    ),
    linewidth = 1.5
  ) +
  labs(
    x = "Day since first report",
    y = "Cumulative cases",
    color = "Type"
  )
```

:::::::::::::::::::::: testimonial

### Early spread projections

In the initial phase of the epidemic you can use `{epichains}` to apply a branching process model to project the number of future cases. Validation analysis showed that this is a rapid and low detail model with forecast prediction intervals that are too certain ([Pearson et al., 2020](https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2020.25.18.2000543#validationofthemodel-1)).

We invite you to read the vignette on [Projecting infectious disease incidence: a COVID-19 example](https://epiverse-trace.github.io/epichains/articles/projecting_incidence.html)!

::::::::::::::::::::::

## Challenges

:::::::::::::::::::::::::: challenge

Evaluate for ebola with know data from previous outbreaks

:::::::::::::: hint

::::::::::::::

:::::::::::::: solution

```{r,message=FALSE,warning=FALSE}
ebola_offspring <- epidist_db(
  disease = "ebola",
  epi_dist = "offspring",
  single_epidist = TRUE
)

ebola_serial <- epidist_db(
  disease = "ebola",
  epi_dist = "serial interval",
  single_epidist = TRUE
)
```

::::::::::::::

:::::::::::::::::::::::::

:::::::::::::::::::::::::: challenge

from paper
Christian Althaus
<https://www.thelancet.com/journals/laninf/article/PIIS1473-3099(15)70135-0/fulltext>

data from Fayre et al on ebola

```{r,message=FALSE,warning=FALSE}
# Number of individuals in the trees
n <- 152
# Number of secondary cases for all individuals
c1 <- c(1, 2, 2, 5, 14, 1, 4, 4, 1, 3, 3, 8, 2, 1, 1,
        4, 9, 9, 1, 1, 17, 2, 1, 1, 1, 4, 3, 3, 4, 2,
        5, 1, 2, 2, 1, 9, 1, 3, 1, 2, 1, 1, 2)
c0 <- c(c1, rep(0, n - length(c1)))

c0 %>%
  enframe() %>%
  ggplot(aes(value)) +
  geom_histogram()
```


::::::::::: hint

...

:::::::::::

::::::::::: solution

remarkable even with R0 less than 1
with potentially explosive outbreaks

the observed variation in individual infectiousness in Ebola
means that although the probability of extinction is high,
new index cases also have the potential for explosive
regrowth of the epidemic.

:::::::::::

:::::::::::::::::::::::::::::

:::::::::::::::::::: challenge

Calculate probabilities for Ebola using data from epiparameter using `{superspreading}`

:::::::::::::::::: hint

```{r,message=FALSE,warning=FALSE}
library(superspreading)
```

```{r}
# estimate probability to contain
probability_contain(
  R = mers_offspring["mean"],
  k = mers_offspring["dispersion"],
  num_init_infect = 1,
  case_threshold = 100
)

# Estimate probability of large outbreak
# with 5 independent imported cases
probability_epidemic(
  R = mers_offspring["mean"],
  k = mers_offspring["dispersion"],
  num_init_infect = 5
)
```

::::::::::::::::::

:::::::::::::::::: solution

```{r}
#' get ebola params
```

::::::::::::::::::

:::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::: testimonial

you can use early linelist data as seed cases to make short term projection of cases

take a look to vignette

<https://epiverse-trace.github.io/epichains/articles/projecting_incidence.html>

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: keypoints 

- Use `{epichains}`

::::::::::::::::::::::::::::::::::::::::::::::::

