---
title: 'Simulate transmission chains'
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- How to simulate transmission chains?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Create a short term projection using branching process with `{epichains}`.

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: prereq

## Prerequisites

Learners should familiarise themselves with following concept dependencies before working through this tutorial: 

**Statistics**: probability distributions. 

**Epidemic theory**: Reproduction number.

:::::::::::::::::::::::::::::::::

## Introduction

<!-- what we know -->

<!-- what we dont know -->

<!-- what we are going to do -->

We are going to use `{purrr}`

```{r,message=FALSE,warning=FALSE}
library(epichains)
library(epiparameter)
library(tidyverse)
```

## Superspreading in decision making

Transmission heterogeneity affects epidemic establishment and the ease of control ([Cori et al., 2017](https://royalsocietypublishing.org/doi/10.1098/rstb.2016.0371)). 

+ Greater heterogeneity reduces the chance of an outbreak emerging from single case. Individuals with more extreme amount of secondary cases are rare.

+ However, if the outbreak gets established, this heterogeneity can make an outbreak hard to control using *mass interventions* (which assumes transmission homogeneity), as a single uncontrolled case can generate a large number of secondary cases.

+ Conversely, heterogeneity in transmission may provide opportunities for *targeted interventions* if the individuals who contribute more to transmission (due to biological, environmental or behavioral factors) share socio-demographic or geographical characteristics that can be defined.

We can have an early understanding of a disease epidemic potential from the mean reproduction number $R_{0}$ and dispersion $k$ of an offspring distribution to answer questions like:

- What is the probability of an pathogen to cause large outbreak?
- What is the probability of an outbreak to get extinct?
- What is the probability to contain the ongoing outbreak?

::::::::::::::::::::::::::: testimonial

### Epidemic Risk assessment accounting for superspreading

These estimates vary non-linearly with respect to the mean reproduction number $R_{0}$ and dispersion $k$ of a given disease.

We invite you to read the `{superspreading}` vignette on [Epidemic risk](https://epiverse-trace.github.io/superspreading/articles/epidemic_risk.html)!

:::::::::::::::::::::::::::

## Simulation of uncontrolled outbreaks

simulation of uncontrolled outbreaks

- branching process
    + To assess the effect of individual variation on disease outbreaks, we analyse a branching process model with negative binomial offspring distribution

- estimate tree parameters using branching process
    + estimate size
    + estimate length

with estimated parameter we then can reconstruct tranmission chains to forecast and simulate interventions

### branching process

- probability generating function (pgf) of the offspring distribution 

## Get the offspring distribution

from MERS estimates in estimate episode

```{r}
mers_offspring <-
  c(
    mean = 0.60,
    dispersion = 0.02
  )

mers_offspring
```

instead of the offspring distribution
we can also define a poisson process
using the lambda distribution parameter
lambda = rate = mean


## Get generation time

```{r,message=FALSE,warning=FALSE}
serial_inverval <- epidist_db(
  disease = "mers",
  epi_dist = "serial",
  single_epidist = TRUE
)

plot(serial_inverval, day_range = 0:25)

serial_inverval$summary_stats %>%
  as_tibble() %>%
  select(mean, sd) %>%
  distinct(.keep_all = TRUE)
```

Similar to the `{cfr}` interface for `{epiparameter}`

```r
function(x) generate(x = serial_inverval, times = x)
```

## Simulate a single chain

`simulate_chains()` generates a `<epichains>` object

```{r,message=FALSE,warning=FALSE,eval=FALSE}
simulate_chains(
  # simulation controls
  index_cases = 5,
  statistic = "size",
  # offspring
  offspring_dist = rnbinom,
  mu = mers_offspring["mean"],
  size = mers_offspring["dispersion"],
  # generation
  generation_time = function(x) generate(x = serial_inverval, times = x)
)
```

the output dataframe collects
infectees as observation unit
each infectee has a sim_id
the infector sim_id of each infectee is in infector_id
infectee got infected in generation and time
as part of the `chain_id` chain

## Simulate multiple chains

```{r}
# Set seed for random number generator
set.seed(33)
# Number of simulation runs
number_chains <- 1000
# Number of initial cases
initial_cases <- 1

```

:::::::::::::::::::::::::::::: checklist

### Iteration using purrr

[Iteration](https://r4ds.hadley.nz/iteration.html) aims to repeatedly perform the same action on different objects.

Learn how to use the core `{purrr}` functions like `map()` from the YouTube tutorial on [How to purrr](https://www.youtube.com/watch?v=nd-Y8b22YaQ) by Equitable Equations.

Or if you previously used the `*apply` family of functions, visit the package vignette on [purrr base R](https://purrr.tidyverse.org/articles/base.html) shares key differences, direct translations, and examples.

::::::::::::::::::::::::::::::

To get multiple chains, we need to apply the `simulate_chains()` function to each chain defined by a sequence of numbers from 1 to `number_chains`.

Let's use `map()`:

```{r}
simulated_chains_map <-
  # iterate one function across multiple numbers (chain IDs)
  map(
    # vector of numbers (chain IDs)
    .x = seq_len(number_chains),
    # function to iterate to each chain ID number
    .f = function(sim) {
      simulate_chains(
        # simulation controls
        index_cases = initial_cases,
        statistic = "size",
        # offspring
        offspring_dist = rnbinom,
        mu = mers_offspring["mean"],
        size = mers_offspring["dispersion"],
        # generation
        generation_time = function(x) generate(x = serial_inverval, times = x)
      ) %>%
        # creates a column with the chain ID number
        mutate(chain_id = sim)
    }
  ) %>%
  # combine list outputs (for each chain ID) into a single data frame
  list_rbind()
```

```{r,echo=FALSE,eval=FALSE}
# view infectee number per simulation
simulated_chains_map %>%
  as_tibble() %>%
  count(chain_id, sort = TRUE)
```

```{r,echo=FALSE}
#### get simulated chain with more infections --------------------------------

chains_subgroup <- simulated_chains_map %>%
  as_tibble() %>%
  group_by(chain_id) %>%
  distinct(infector_id) %>%
  count(chain_id) %>%
  filter(n < 5, n >= 3) %>%
  pull(chain_id)

chain_to_observe <- simulated_chains_map %>%
  as_tibble() %>%
  count(chain_id, sort = TRUE) %>%
  filter(
    magrittr::is_in(
      chain_id, chains_subgroup
    )
  ) %>%
  filter(n < 10) %>%
  filter(n == max(n)) %>%
  slice_min(chain_id) %>%
  pull(chain_id)
```

Let's observe closely the simulated `chain_id` number `r chain_to_observe` with three generations.

get epichain summary

```{r}
#### get epichain summary ----------------------------------------------------

simulated_chains_map %>%
  filter(chain_id == chain_to_observe)
```

the `NA` includes the infector of the index case, for that reason (known) cases

infectee-infector data frame

```{r}
#### infector-infectee data frame --------------------------------------------

simulated_chains_map %>%
  filter(chain_id == chain_to_observe) %>%
  as_tibble()
```


## Visualize multiple chains

```{r}
# daily aggregate of cases
simulated_chains_day <-
  simulated_chains_map %>%
  as_tibble() %>%
  mutate(chain_id = as_factor(chain_id)) %>%
  # Daily number of cases for each simulation
  mutate(day = ceiling(time)) %>%
  count(chain_id, day, name = "cases") %>%
  # Cumulative number of cases for each simulation
  group_by(chain_id) %>%
  mutate(cases_cumsum = cumsum(cases)) %>%
  ungroup()
```

```{r}
# Summarise the chain length and size
sim_chains_max <-
  simulated_chains_day %>%
  group_by(chain_id) %>%
  summarise(
    # length
    day_max = max(day),
    # size
    cases_total = max(cases_cumsum)
  ) %>%
  ungroup()
```

```{r}
# Visualize transmission chains by cumulative cases
ggplot() +
  geom_line(
    data = simulated_chains_day,
    mapping = aes(
      x = day,
      y = cases_cumsum,
      group = chain_id,
      color = chain_id
    ),
    show.legend = FALSE
  ) +
  geom_point(
    data = sim_chains_max,
    mapping = aes(
      x = day_max,
      y = cases_total,
      group = chain_id,
      color = chain_id
    ),
    show.legend = FALSE
  ) +
  geom_hline(aes(yintercept = 100), lty = 2) +
  labs(
    x = "Day",
    y = "Cumulative cases"
  )
```


```{r,echo=FALSE,message=FALSE,warning=FALSE}
# proportion that reached the 100-case threshold
threshhold_summary <- sim_chains_max %>%
  arrange(desc(day_max)) %>%
  filter(cases_total > 100) %>%
  count(name = "chains_theshold") %>%
  mutate(chains_number = number_chains) %>%
  mutate(chains_percentage = chains_theshold / chains_number * 100)

chains_extinct <- sim_chains_max %>%
  arrange(desc(day_max)) %>%
  filter(day_max > 0) %>%
  summarise(
    extinct_length_median = median(day_max),
    extinct_size_median = median(cases_total)
  )

chains_null <- sim_chains_max %>%
  arrange(desc(cases_total)) %>%
  filter(day_max < 1) %>%
  nrow()
```

Although most introductions do not generate secondary cases (N = `r chains_null`) or most outbreaks rapidly become extinct (median length of `r chains_extinct$extinct_length_median` and median size of `r chains_extinct$extinct_size_median`), only `r threshhold_summary$chains_theshold` epidemic trajectories among `r threshhold_summary$chains_number` simulations (`r threshhold_summary$chains_percentage`%) can reach to more than 100 infected cases. This finding is particularly remarkable because the basic reproduction number $R_0$ is less than 1 (offspring distribution mean of `r mers_offspring[["mean"]]`), but, given an offspring distribution dispersion parameter of `r mers_offspring[["dispersion"]]`, it shows the potential for explosive outbreaks of MERS disease.

::::::::::::::::::::::::::::::::::: spoiler

### Observed cases vs simulated chains

Let's overlap the cumulative number of observed cases using the linelist object from the `mers_korea_2015` dataset of the `{outbreaks}` R package. To prepare the dataset we use `{incidence2}` to convert the linelist to an `<incidence2>` object, complete the missing dates of the time series with `complete_dates()`

```{r,warning=FALSE,message=FALSE}
library(outbreaks)

mers_cumcases <- mers_korea_2015$linelist %>%
  # incidence2 workflow
  incidence2::incidence(date_index = "dt_onset") %>%
  incidence2::complete_dates() %>%
  # wrangling using {dplyr}
  mutate(count_cumsum = cumsum(count)) %>%
  rownames_to_column(var = "day") %>%
  mutate(day = as.numeric(day))
```

Use `plot()` to make an incidence plot:

```{r}
# plot the incidence2 object
plot(mers_cumcases)
```

:::::::::::::::::::::::::::::::::::

When plotting the observed number of cumulative cases from the Middle East respiratory syndrome (MERS) outbreak in South Korea in 2015, alongside the previously simulated chains, we identify that the observed cases followed a trajectory that resembled one of the simulated explosive outbreaks.

```{r,echo=FALSE}
# Observed cases vs Simulated transmission chains
mers_cumcases_type <-
  mers_cumcases %>%
  mutate(type = "Observed")
simulated_chains_day_type <-
  simulated_chains_day %>%
  mutate(type = "Simulated")

ggplot() +
  geom_line(
    data = simulated_chains_day_type,
    mapping = aes(
      x = day,
      y = cases_cumsum,
      group = chain_id,
      color = type
    )
  ) +
  geom_hline(aes(yintercept = 100), lty = 2) +
  geom_line(
    data = mers_cumcases_type,
    mapping = aes(
      x = day,
      y = count_cumsum,
      color = type
    ),
    linewidth = 1.5
  ) +
  labs(
    x = "Day since first report",
    y = "Cumulative cases",
    color = "Type"
  )
```

:::::::::::::::::::::: testimonial

### Early spread projections

In the initial phase of the epidemic you can use `{epichains}` to apply a branching process model to project the number of future cases. Validation analysis showed that this is a rapid and low detail model with forecast prediction intervals that are too certain ([Pearson et al., 2020](https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2020.25.18.2000543#validationofthemodel-1)).

We invite you to read the vignette on [Projecting infectious disease incidence: a COVID-19 example](https://epiverse-trace.github.io/epichains/articles/projecting_incidence.html)!

::::::::::::::::::::::

## Challenges

:::::::::::::::::::::::::: challenge

Evaluate for ebola with know data from previous outbreaks

:::::::::::::: hint

::::::::::::::

:::::::::::::: solution

```{r,message=FALSE,warning=FALSE}
ebola_offspring <- epidist_db(
  disease = "ebola",
  epi_dist = "offspring",
  single_epidist = TRUE
)

ebola_serial <- epidist_db(
  disease = "ebola",
  epi_dist = "serial interval",
  single_epidist = TRUE
)
```

::::::::::::::

:::::::::::::::::::::::::

:::::::::::::::::::::::::: challenge

from paper
Christian Althaus
<https://www.thelancet.com/journals/laninf/article/PIIS1473-3099(15)70135-0/fulltext>

data from Fayre et al on ebola

```{r,message=FALSE,warning=FALSE}
# Number of individuals in the trees
n <- 152
# Number of secondary cases for all individuals
c1 <- c(1, 2, 2, 5, 14, 1, 4, 4, 1, 3, 3, 8, 2, 1, 1,
        4, 9, 9, 1, 1, 17, 2, 1, 1, 1, 4, 3, 3, 4, 2,
        5, 1, 2, 2, 1, 9, 1, 3, 1, 2, 1, 1, 2)
c0 <- c(c1, rep(0, n - length(c1)))

c0 %>%
  enframe() %>%
  ggplot(aes(value)) +
  geom_histogram()
```


::::::::::: hint

...

:::::::::::

::::::::::: solution

remarkable even with R0 less than 1
with potentially explosive outbreaks

the observed variation in individual infectiousness in Ebola
means that although the probability of extinction is high,
new index cases also have the potential for explosive
regrowth of the epidemic.

:::::::::::

:::::::::::::::::::::::::::::

:::::::::::::::::::: challenge

Calculate probabilities for Ebola using data from epiparameter using `{superspreading}`

:::::::::::::::::: hint

```{r,message=FALSE,warning=FALSE}
library(superspreading)
```

```{r}
# estimate probability to contain
probability_contain(
  R = mers_offspring["mean"],
  k = mers_offspring["dispersion"],
  num_init_infect = 1,
  case_threshold = 100
)

# Estimate probability of large outbreak
# with 5 independent imported cases
probability_epidemic(
  R = mers_offspring["mean"],
  k = mers_offspring["dispersion"],
  num_init_infect = 5
)
```

::::::::::::::::::

:::::::::::::::::: solution

```{r}
#' get ebola params
```

::::::::::::::::::

:::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::: testimonial

you can use early linelist data as seed cases to make short term projection of cases

take a look to vignette

<https://epiverse-trace.github.io/epichains/articles/projecting_incidence.html>

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: keypoints 

- Use `{epichains}`

::::::::::::::::::::::::::::::::::::::::::::::::

