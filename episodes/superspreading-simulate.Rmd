---
title: 'Simulate transmission chains'
teaching: 10
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- How to simulate transmission chains?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Create a short term projection using branching process with `{epichains}`.

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: prereq

## Prerequisites

Learners should familiarise themselves with following concept dependencies before working through this tutorial: 

**Statistics**: probability distributions. 

**Epidemic theory**: Reproduction number.

:::::::::::::::::::::::::::::::::

## questions

## Introduction

<!-- what we know -->

<!-- what we dont know -->

<!-- what we are going to do -->

We are going to use `{purrr}`

```{r,message=FALSE,warning=FALSE}
library(epichains)
library(tidyverse)
```

## Simulation of uncontrolled outbreaks

simulation of uncontrolled outbreaks

- branching process
    + To assess the effect of individual variation on disease outbreaks, we analyse a branching process model with negative binomial offspring distribution

- estimate tree parameters using branching process
    + estimate size
    + estimate length

with estimated parameter we then can reconstruct tranmission chains to forecast and simulate interventions

### branching process

- probability generating function (pgf) of the offspring distribution 

## Get the offspring distribution

from MERS estimates in estimate episode

```{r}
mers_offspring <-
  c(
    mean = 0.60,
    dispersion = 0.02
  )

mers_offspring
```

instead of the offspring distribution
we can also define a poisson process
using the lambda distribution parameter
lambda = rate = mean


## Get generation time

```{r}
library(epiparameter)

serial_inverval <- epidist_db(
  disease = "mers",
  epi_dist = "serial",
  single_epidist = TRUE
)

serial_inverval
```

Similar to the `{cfr}` interface for `{epiparameter}`

```r
function(x) generate(x = serial_inverval,times = x)
```

## Simulate a single chain

```{r}
simulate_chains(
  # simulation controls
  index_cases = 5,
  statistic = "size",
  # offspring
  offspring_dist = rnbinom,
  mu = mers_offspring["mean"],
  size = mers_offspring["dispersion"],
  # generation
  generation_time = function(x) generate(x = serial_inverval, times = x)
) %>%
  as_tibble()
```

the output dataframe collects
infectees as observation unit
each infectee has a sim_id
the infector sim_id of each infectee is in infector_id
infectee got infected in generation and time
as part of the `chain_id` chain

## Simulate multiple chains

```{r}
# Set seed for random number generator
set.seed(33)
# Number of simulation runs
number_chains <- 1000
# Number of initial cases
initial_cases <- 1

```

:::::::::::::::::::::::::::::: checkpoint

### Iteration using {purrr}

[Iteration](https://r4ds.hadley.nz/iteration.html) aims to repeatedly perform the same action on different objects.

Learn how to use the core `{purrr}` functions like the `map_*()` family of functions from the YouTube tutorial on [How to purrr](https://www.youtube.com/watch?v=nd-Y8b22YaQ) by Equitable Equations.

Or if you previously used the `*apply` family of functions, visit the package vignette on [purrr base R](https://purrr.tidyverse.org/articles/base.html) shares key differences, direct translations, and examples.

::::::::::::::::::::::::::::::

To get multiple chains, we need to apply the `simulate_chains()` function to each chain defined by a sequence of numbers from 1 to `number_chains`.

Let's use `map()`:

```{r}
simulated_chains_list <-
  map(
    # vector of numbers (chain IDs)
    .x = seq_len(number_chains),
    # function to iterate to each chain ID number
    .f = function(sim) {
      simulate_chains(
        # simulation controls
        index_cases = initial_cases,
        statistic = "size",
        # offspring
        offspring_dist = rnbinom,
        mu = mers_offspring["mean"],
        size = mers_offspring["dispersion"],
        # generation
        generation_time = function(x) generate(x = serial_inverval, times = x)
      ) %>%
        # creates a column with the chain ID number
        mutate(chain_id = sim)
    }
  )

sim_chains_bind <- bind_rows(simulated_chains_list)

sim_chains_bind
```

```{r}
# view infectee number per simulation
sim_chains_bind %>%
  as_tibble() %>%
  count(chain_id, sort = TRUE)
```

```{r,echo=FALSE}
#### get simulated chain with more infections --------------------------------

chains_subgroup <- sim_chains_bind %>%
  as_tibble() %>%
  group_by(chain_id) %>%
  distinct(infector_id) %>%
  count(chain_id) %>%
  filter(n < 5, n >= 3) %>%
  pull(chain_id)

chain_to_observe <- sim_chains_bind %>%
  as_tibble() %>%
  count(chain_id, sort = TRUE) %>%
  filter(
    magrittr::is_in(
      chain_id, chains_subgroup
    )
  ) %>%
  filter(n < 10) %>%
  filter(n == max(n)) %>%
  slice_min(chain_id) %>%
  pull(chain_id)
```

get simulated chain `r chain_to_observe` with more infections

get epichain summary

```{r}
#### get epichain summary ----------------------------------------------------

simulated_chains_list %>%
  pluck(chain_to_observe)
```

the `NA` includes the infector of the index case, for that reason (known) cases

infectee-infector data frame

```{r}
#### infector-infectee data frame --------------------------------------------

simulated_chains_list %>%
  pluck(chain_to_observe) %>%
  as.data.frame()
```


## Visualize multiple chains

```{r}
# daily aggregate of cases
simulated_chains_day <-
  sim_chains_bind %>%
  as_tibble() %>%
  mutate(chain_id = as_factor(chain_id)) %>%
  # Daily number of cases for each simulation
  mutate(day = ceiling(time)) %>%
  count(chain_id, day, name = "cases") %>%
  # Cumulative number of cases for each simulation
  group_by(chain_id) %>%
  mutate(cases_cumsum = cumsum(cases)) %>%
  ungroup()

# Summarise the chain length and size
sim_chains_max <-
  simulated_chains_day %>%
  group_by(chain_id) %>%
  summarise(
    # length
    day_max = max(day),
    # size
    cases_total = max(cases_cumsum)
  ) %>%
  ungroup()

# Visualize transmission chains by cumulative cases
ggplot() +
  geom_line(
    data = simulated_chains_day,
    mapping = aes(
      x = day,
      y = cases_cumsum,
      group = chain_id,
      color = chain_id
    ),
    show.legend = FALSE
  ) +
  geom_point(
    data = sim_chains_max,
    mapping = aes(
      x = day_max,
      y = cases_total,
      group = chain_id,
      color = chain_id
    ),
    show.legend = FALSE
  ) +
  geom_hline(aes(yintercept = 100), lty = 2) +
  # xlim(0,150) +
  # ylim(0,300) +
  NULL
```

```{r,eval=FALSE}
# Visualize transmission chains by daily cases
ggplot() +
  geom_line(
    data = simulated_chains_day,
    mapping = aes(
      x = day,
      y = cases,
      group = chain_id,
      color = chain_id
    ),
    show.legend = FALSE
  )
```

:::::::::::::::::::::: testimonial

### Early spread projections

In the initial phase of the epidemic you can use `{epichains}` to apply a branching process model to project the number of future cases. Validation analysis showed that this is a rapid and low detail model with forecast prediction intervals that are too certain ([Pearson et al., 2020](https://www.eurosurveillance.org/content/10.2807/1560-7917.ES.2020.25.18.2000543#validationofthemodel-1)).

We invite you to read the vignette on [Projecting infectious disease incidence: a COVID-19 example](https://epiverse-trace.github.io/epichains/articles/projecting_incidence.html)!

::::::::::::::::::::::

## Challenges

:::::::::::::::::::::::::: challenge

Evaluate for ebola with know data from previous outbreaks

```{r}
epidist_db(
  disease = "ebola",
  epi_dist = "offspring",
  single_epidist = TRUE
)

epidist_db(
  disease = "ebola",
  epi_dist = "serial interval",
  single_epidist = TRUE
)
```


:::::::::::::::::::::::::

:::::::::::::::::::::::::: challenge

from paper
Christian Althaus
<https://www.thelancet.com/journals/laninf/article/PIIS1473-3099(15)70135-0/fulltext>

data from Fayre et al on ebola

```{r}
# Number of individuals in the trees
n <- 152
# Number of secondary cases for all individuals
c1 <- c(1, 2, 2, 5, 14, 1, 4, 4, 1, 3, 3, 8, 2, 1, 1,
        4, 9, 9, 1, 1, 17, 2, 1, 1, 1, 4, 3, 3, 4, 2,
        5, 1, 2, 2, 1, 9, 1, 3, 1, 2, 1, 1, 2)
c0 <- c(c1, rep(0, n - length(c1)))

c0 %>%
  enframe() %>%
  ggplot(aes(value)) +
  geom_histogram()
```


::::::::::: hint

...

:::::::::::

::::::::::: solution

remarkable even with R0 less than 1
with potentially explosive outbreaks

the observed variation in individual infectiousness in Ebola
means that although the probability of extinction is high,
new index cases also have the potential for explosive
regrowth of the epidemic.

:::::::::::

:::::::::::::::::::::::::::::

::::::::::::::::::::::::: testimonial

you can use early linelist data as seed cases to make short term projection of cases

take a look to vignette

<https://epiverse-trace.github.io/epichains/articles/projecting_incidence.html>

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: keypoints 

- Use `{epichains}`

::::::::::::::::::::::::::::::::::::::::::::::::

